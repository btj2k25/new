import Handlebars from 'handlebars';
import fs from 'fs';
import path from 'path';
import { ProjectConfig } from '@shared/schema';

// Register handlebars helpers
Handlebars.registerHelper('if_eq', function(a, b, options) {
  return a === b ? options.fn(this) : options.inverse(this);
});

Handlebars.registerHelper('if_ne', function(a, b, options) {
  return a !== b ? options.fn(this) : options.inverse(this);
});

Handlebars.registerHelper('toLowerCase', function(str) {
  return str.toLowerCase();
});

Handlebars.registerHelper('capitalize', function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

// Function to compile template
export function compileTemplate(templateName: string, data: any): string {
  try {
    const templatePath = path.resolve(import.meta.dirname, 'templates', `${templateName}.template`);
    const templateSource = fs.readFileSync(templatePath, 'utf8');
    const template = Handlebars.compile(templateSource);
    return template(data);
  } catch (error) {
    console.error(`Error compiling template ${templateName}:`, error);
    throw new Error(`Failed to compile template ${templateName}`);
  }
}

// Helper function to check if Lombok is enabled
export function hasLombok(projectConfig: ProjectConfig): boolean {
  return projectConfig.dependencies.some(d => d.id === 'lombok' && d.selected);
}

// Helper function to camelCase a string
export function camelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// Generate package name based on project config
export function generatePackageName(projectConfig: ProjectConfig): string {
  return `${projectConfig.groupId}.${projectConfig.artifactId.replace(/[-_]/g, '')}`;
}

// Generate application class name based on project config
export function generateApplicationClassName(projectConfig: ProjectConfig): string {
  let className = projectConfig.artifactId
    .split(/[-_]/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');
  
  return className + 'Application';
}

// Extract ID type from entity fields
export function getEntityIdType(entity: ProjectConfig['entities'][0]): string {
  const idField = entity.fields.find(f => f.name === 'id');
  return idField ? idField.type : 'Long';
}

// Process relationships for entity templates
export function processRelationshipsForEntity(
  entity: ProjectConfig['entities'][0], 
  relationships: ProjectConfig['relationships'], 
  entities: ProjectConfig['entities']
): any[] {
  return relationships
    .filter(r => r.sourceEntityId === entity.id)
    .map(r => {
      const targetEntity = entities.find(e => e.id === r.targetEntityId);
      if (!targetEntity) return null;

      let typeWithField, typeOnly;
      
      if (r.type === '@OneToMany' || r.type === '@ManyToMany') {
        typeWithField = `List<${targetEntity.name}>`;
        typeOnly = `List<${targetEntity.name}>`;
      } else {
        typeWithField = targetEntity.name;
        typeOnly = targetEntity.name;
      }

      let joinColumn, joinTable, inverseJoinColumn;
      if (r.type === '@ManyToOne' || r.type === '@OneToOne') {
        joinColumn = `${camelCase(targetEntity.name)}_id`;
      } else if (r.type === '@ManyToMany') {
        joinTable = `${camelCase(entity.name)}_${camelCase(targetEntity.name)}`;
        joinColumn = `${camelCase(entity.name)}_id`;
        inverseJoinColumn = `${camelCase(targetEntity.name)}_id`;
      }

      return {
        relationshipAnnotation: r.type,
        fieldName: r.fieldName,
        typeWithField,
        typeOnly,
        joinColumn,
        joinTable,
        inverseJoinColumn
      };
    })
    .filter(Boolean);
}

// Check if an entity has timestamp fields
export function hasTimestamps(entity: ProjectConfig['entities'][0]): boolean {
  return entity.fields.some(f => 
    f.name === 'createdAt' || 
    f.name === 'updatedAt' ||
    f.constraints.some(c => c.includes('@CreationTimestamp') || c.includes('@UpdateTimestamp'))
  );
}

// Helper to generate README.md content
export function generateReadmeContent(projectConfig: ProjectConfig): string {
  return `# ${projectConfig.name}

${projectConfig.description || 'A Spring Boot project generated by Spring Boot Project Generator.'}

## Project Details

- **Group ID**: ${projectConfig.groupId}
- **Artifact ID**: ${projectConfig.artifactId}
- **Java Version**: ${projectConfig.javaVersion}
- **Spring Boot Version**: ${projectConfig.springBootVersion}

## Database Configuration

${projectConfig.database.type 
  ? `This project uses ${projectConfig.database.type.toUpperCase()} as the database.`
  : 'No database configured for this project.'}

## Getting Started

### Prerequisites

- JDK ${projectConfig.javaVersion}
- Maven 3.6+
${projectConfig.database.type ? `- ${projectConfig.database.type.toUpperCase()} database` : ''}

### Running the Application

1. Clone the repository
2. Configure the database connection in \`src/main/resources/application.properties\` if needed
3. Run the application using Maven:

\`\`\`bash
mvn spring-boot:run
\`\`\`

${projectConfig.generationOptions.documentation !== 'none' 
  ? `## API Documentation

API documentation is available when the application is running:

${projectConfig.generationOptions.documentation === 'swagger' 
  ? '- Swagger UI: http://localhost:8080/swagger-ui.html'
  : '- SpringDoc OpenAPI: http://localhost:8080/swagger-ui.html'
}
${projectConfig.generationOptions.documentation === 'springdoc' 
  ? '- OpenAPI JSON: http://localhost:8080/api-docs'
  : '- Swagger JSON: http://localhost:8080/api-docs'
}` 
  : ''}

## Project Structure

The project has the following structure:

\`\`\`
src/
├── main/
│   ├── java/
│   │   └── ${projectConfig.groupId.replace(/\./g, '/')}/${projectConfig.artifactId.replace(/[-_]/g, '')}/
${projectConfig.generationOptions.controllers ? '│   │       ├── controller/\n' : ''}${projectConfig.generationOptions.services ? '│   │       ├── service/\n' : ''}${projectConfig.generationOptions.repositories ? '│   │       ├── repository/\n' : ''}│   │       └── entity/
│   └── resources/
│       ├── application.properties
│       └── static/
└── test/
    └── java/
        └── ${projectConfig.groupId.replace(/\./g, '/')}/${projectConfig.artifactId.replace(/[-_]/g, '')}/
\`\`\`

${projectConfig.entities.length > 0 
  ? `## Entity Diagram

This project contains the following entities:

${projectConfig.entities.map(e => `- ${e.name}`).join('\n')}

${projectConfig.relationships.length > 0 
  ? 'With the following relationships:\n\n' + 
    projectConfig.relationships.map(r => {
      const sourceEntity = projectConfig.entities.find(e => e.id === r.sourceEntityId);
      const targetEntity = projectConfig.entities.find(e => e.id === r.targetEntityId);
      return `- ${sourceEntity?.name} ${r.type.replace('@', '')} ${targetEntity?.name} (via field '${r.fieldName}')`;
    }).join('\n')
  : ''}`
  : ''}

${projectConfig.generationOptions.docker 
  ? `## Docker Support

A Dockerfile is included to containerize the application. To build and run with Docker:

\`\`\`bash
docker build -t ${projectConfig.artifactId} .
docker run -p 8080:8080 ${projectConfig.artifactId}
\`\`\`
${projectConfig.generationOptions.dockerCompose 
  ? `
You can also use Docker Compose to run the application along with its dependencies:

\`\`\`bash
docker-compose up
\`\`\``
  : ''}`
  : ''}
`;
}

// Helper to generate .gitignore content
export function generateGitignoreContent(): string {
  return `HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Logs ###
*.log
logs/
`;
}

// Helper to generate Dockerfile content
export function generateDockerfileContent(projectConfig: ProjectConfig): string {
  return `FROM eclipse-temurin:${projectConfig.javaVersion}-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN ./mvnw install -DskipTests
RUN mkdir -p target/dependency && (cd target/dependency; jar -xf ../*.${projectConfig.packageType})

FROM eclipse-temurin:${projectConfig.javaVersion}-jre-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","${generatePackageName(projectConfig)}.${generateApplicationClassName(projectConfig)}"]
`;
}

// Helper to generate Docker Compose content
export function generateDockerComposeContent(projectConfig: ProjectConfig): string {
  let dbConfig = '';
  if (projectConfig.database.type) {
    switch (projectConfig.database.type) {
      case 'postgresql':
        dbConfig = `
  db:
    image: postgres:14
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_PASSWORD=${projectConfig.database.options.password || 'password'}
      - POSTGRES_USER=${projectConfig.database.options.username || 'postgres'}
      - POSTGRES_DB=${projectConfig.database.options.name || projectConfig.artifactId}
    volumes:
      - postgres_data:/var/lib/postgresql/data`;
        break;
      case 'mysql':
        dbConfig = `
  db:
    image: mysql:8
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=${projectConfig.database.options.password || 'root'}
      - MYSQL_USER=${projectConfig.database.options.username || 'mysql'}
      - MYSQL_PASSWORD=${projectConfig.database.options.password || 'password'}
      - MYSQL_DATABASE=${projectConfig.database.options.name || projectConfig.artifactId}
    volumes:
      - mysql_data:/var/lib/mysql`;
        break;
      case 'mongodb':
        dbConfig = `
  db:
    image: mongo:5
    ports:
      - "27017:27017"
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${projectConfig.database.options.username || 'mongo'}
      - MONGO_INITDB_ROOT_PASSWORD=${projectConfig.database.options.password || 'password'}
      - MONGO_INITDB_DATABASE=${projectConfig.database.options.name || projectConfig.artifactId}
    volumes:
      - mongo_data:/data/db`;
        break;
    }
  }

  return `version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    depends_on:${projectConfig.database.type ? `
      - db` : ''}
    environment:
      - SPRING_PROFILES_ACTIVE=docker${projectConfig.database.type ? `
      - SPRING_DATASOURCE_URL=jdbc:${projectConfig.database.type}://db:${projectConfig.database.type === 'postgresql' ? '5432' : projectConfig.database.type === 'mysql' ? '3306' : '27017'}/${projectConfig.database.options.name || projectConfig.artifactId}
      - SPRING_DATASOURCE_USERNAME=${projectConfig.database.options.username || 'user'}
      - SPRING_DATASOURCE_PASSWORD=${projectConfig.database.options.password || 'password'}` : ''}${dbConfig}

volumes:${projectConfig.database.type ? `
  ${projectConfig.database.type}_data:` : ''}
`;
}
